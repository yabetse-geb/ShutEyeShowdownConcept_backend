/**
 * This script automates the creation of barrel files for concept imports.
 * It scans a specified directory for concept implementations and generates
 * two files:
 *  - `concepts.ts`: For production use, instantiating concepts with the main database.
 *  - `test_concepts.ts`: For testing, instantiating concepts with a separate test database.
 *
 * This enables convenient, typed imports like:
 * `import { User, Post } from "@concepts";`
 * `import { User, Post } from "@test-concepts";`
 *
 * Run this script using `deno task import`.
 */
import * as path from "jsr:@std/path";
import { walk } from "jsr:@std/fs";

// 1. Configuration
const CONCEPTS_DIR = Deno.env.get("CONCEPTS_DIR") ?? "src/concepts";
const SYNCS_DIR = Deno.env.get("SYNCS_DIR") ?? "src/syncs";

interface ConceptInfo {
  name: string; // PascalCase name, e.g., "User"
  dirName: string; // Original directory name, e.g., "user"
  importPath: string; // Relative path for import statement, e.g., "./user/UserConcept.ts"
}

/**
 * Scans the base directory to find all valid concept implementations.
 * A valid concept is a directory named `{name}` containing a `{name}Concept.ts` file.
 */
async function discoverConcepts(baseDir: string): Promise<ConceptInfo[]> {
  const concepts: ConceptInfo[] = [];
  const absoluteBaseDir = path.resolve(baseDir);

  for await (const dirEntry of Deno.readDir(absoluteBaseDir)) {
    if (!dirEntry.isDirectory) {
      continue;
    }

    const conceptDirName = dirEntry.name;
    const expectedFileName = `${conceptDirName}Concept.ts`;
    const conceptFilePath = path.join(
      absoluteBaseDir,
      conceptDirName,
      expectedFileName,
    );

    try {
      await Deno.stat(conceptFilePath); // Check if file exists
      const conceptName = conceptDirName.charAt(0).toUpperCase() +
        conceptDirName.slice(1);

      concepts.push({
        name: conceptName,
        dirName: conceptDirName,
        importPath: `./${conceptDirName}/${expectedFileName}`,
      });
      console.log(`  -> Found concept: ${conceptName}`);
    } catch (error) {
      if (error instanceof Deno.errors.NotFound) {
        // This directory doesn't contain a concept file, so we ignore it.
      } else {
        // Re-throw other unexpected errors.
        throw error;
      }
    }
  }
  return concepts;
}

/**
 * Generates the full content for a barrel file (either production or test).
 */
function generateBarrelFileContent(
  concepts: ConceptInfo[],
  isTest: boolean,
): string {
  const header =
    `// This file is auto-generated by the \`generate_imports.ts\` script.
// Do not edit it manually, unless you know your concept requires a custom instantiation procedure.

import { SyncConcept } from "@engine";

export const Engine = new SyncConcept();\n`;

  const dbImportFunc = isTest ? "testDb" : "getDb";
  const dbImport = `import { ${dbImportFunc} } from "@utils/database.ts";\n`;

  const conceptClassImports = concepts
    .map((c) => `import ${c.name}Concept from "${c.importPath}";`)
    .join("\n");

  const conceptTypeExports = concepts
    .map(
      (c) =>
        `export type { default as ${c.name}Concept } from "${c.importPath}";`,
    )
    .join("\n");

  const dbInitialization = `
// Initialize the database connection
export const [db, client] = await ${dbImportFunc}();
`;

  const instantiations = concepts
    .map((c) =>
      `export const ${c.name} = Engine.instrumentConcept(new ${c.name}Concept(db));`
    )
    .join("\n");

  return [
    header,
    dbImport,
    conceptClassImports,
    "", // newline
    conceptTypeExports,
    dbInitialization,
    instantiations,
    "", // trailing newline
  ].join("\n");
}

interface SyncInfo {
  prefix: string; // Fully-qualified prefix, e.g., "user.login"
  importAlias: string; // Sanitized alias for import, e.g., "sync_user_login"
  importPath: string; // Relative path for import, e.g., "./user/login.sync.ts"
}

/**
 * Scans the base directory recursively to find all sync implementation files.
 * A valid sync file is any file ending with `.sync.ts`.
 */
async function discoverSyncs(baseDir: string): Promise<SyncInfo[]> {
  const syncs: SyncInfo[] = [];
  const absoluteBaseDir = path.resolve(baseDir);

  try {
    for await (
      const entry of walk(absoluteBaseDir, {
        includeFiles: true,
        includeDirs: false,
        exts: [".sync.ts"],
      })
    ) {
      const filePath = entry.path;
      const relativePath = path.relative(absoluteBaseDir, filePath);
      const prefix = relativePath
        .replace(/\.sync\.ts$/, "")
        .replaceAll(path.SEPARATOR, ".");

      const importAlias = `sync_${prefix.replaceAll(".", "_")}`;
      // Ensure import path uses forward slashes for cross-platform compatibility
      const importPath = `./${relativePath.replaceAll(path.SEPARATOR, "/")}`;

      syncs.push({
        prefix,
        importAlias,
        importPath,
      });
      console.log(`  -> Found sync file: ${relativePath}`);
    }
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      // The syncs directory might not exist, which is fine.
      return [];
    }
    throw error;
  }
  return syncs;
}

/**
 * Generates the full content for the syncs barrel file.
 */
function generateSyncsBarrelFileContent(syncs: SyncInfo[]): string {
  const header =
    `// This file is auto-generated by the \`generate_imports.ts\` script.\n// Do not edit it manually.\n\n`;
  const typeImport = `import type { Sync } from "@engine";\n`;

  const syncImports = syncs
    .map((s) => `import * as ${s.importAlias} from "${s.importPath}";`)
    .join("\n");

  const instantiation = `\nconst allSyncs: Record<string, Sync> = {};\n`;

  const populationLogic = syncs
    .map(
      (s) => `
for (const [name, func] of Object.entries(${s.importAlias})) {
  if (typeof func === "function") {
    allSyncs[\`${s.prefix}.\${name}\`] = func as Sync;
  }
}`,
    )
    .join("");

  return [
    header,
    typeImport,
    syncImports,
    instantiation,
    populationLogic,
    "\nexport default allSyncs;\n",
  ]
    .join("\n");
}

/**
 * Main execution function.
 */
async function main() {
  console.log(`Scanning for concepts in '${CONCEPTS_DIR}'...`);
  const concepts = await discoverConcepts(CONCEPTS_DIR);

  if (concepts.length === 0) {
    console.warn("Warning: No concepts found. Generated files will be empty.");
  }

  // Generate production barrel file
  const prodContent = generateBarrelFileContent(concepts, false);
  const prodFilePath = path.join(CONCEPTS_DIR, "concepts.ts");
  await Deno.writeTextFile(prodFilePath, prodContent);
  console.log(`✅ Generated production barrel file: ${prodFilePath}`);

  // Generate test barrel file
  const testContent = generateBarrelFileContent(concepts, true);
  const testFilePath = path.join(CONCEPTS_DIR, "test_concepts.ts");
  await Deno.writeTextFile(testFilePath, testContent);
  console.log(`✅ Generated test barrel file: ${testFilePath}`);

  // 2. Generate Syncs File
  console.log(`\nScanning for syncs in '${SYNCS_DIR}'...`);
  const syncs = await discoverSyncs(SYNCS_DIR);

  if (syncs.length === 0) {
    console.warn(
      "Warning: No syncs found. Generated syncs file will be empty.",
    );
  }

  const syncsContent = generateSyncsBarrelFileContent(syncs);
  const syncsFilePath = path.join(SYNCS_DIR, "syncs.ts");
  await Deno.writeTextFile(syncsFilePath, syncsContent);
  console.log(`✅ Generated syncs barrel file: ${syncsFilePath}`);
}

// Run the main function if this script is executed directly.
if (import.meta.main) {
  main().catch((err) => {
    console.error("Error generating import files:", err);
    Deno.exit(1);
  });
}
